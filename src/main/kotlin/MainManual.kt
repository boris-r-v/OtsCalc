import ots.calc.*
import ots.calc.Mesh
import ots.calc.Track
import ots.complex.*
import ots.statistic.Data
import ots.statistic.MoveImitator

/**
 * -------!!Руководство пользователя системы анализа обратной тяговой сети!!----------
 *
 * Как это работает:
 * 1. Все начинается с класса Compute, который непосредственно производит расчет и анализ
 *      val calc = Compute (
 *           arrayOf(track0,track1,track2,track3,track4,track5),     /*массив путей*/
 *           mps,                                                    /*массив междупутных соедитнителей*/
 *           arrayOf(mesh0,mesh1, mesh2),                            /*массив сеток*/
 *           relativeResist,                                         /*массив межупутных сопротивдления*/
 *       ) *
 *  2. Расчет одной текущей мгновенной схемы производится путем:
 *      calc.calcOts()
 *  3. Получить данные токов и напряжений по каждому пути можно получить из класса путей для только что рассчитанной мгновенной схемы
 *      track.I - массив токов в узлах сетки
 *      track.U - массив напряжений в узлах сетки
 *  4. Класс пути может сохранить рассчитанные токи и напряжения текущей мгновенной схемы в массивы исторических значений
 *      Для этого используется функция copy2Hist, которая в массивы histU/histI сохраняет рассчитанные значения для последней мгновенной схемы
 *      Каждый элемент массива histU/histI - это массивы напряжений/токов для рассчитанных мгновенных схем
 *  Таким образом работа с данным модулей выглядит для первой мгновенной схемы следующим образом:
 *      1. Описали мгновенную схему (что это значит - чуть позже)
 *      2. Инициализировали класс расчета Compute (подготовка необходимых для дальнейшего расчета данных)
 *      3. Вызвали calc.calcOts() - рассчитали данную мгновенную схему, т.е. токи и напряжения в рельсах всех путей
 *      4. Для каждого пути вызывали метод copy2Hist. Это для последующей обработки результатов расчета всех мгновенных схем
 *  Для каждой следующей мгновенной схемы
 *      1. Обновили описание мгновенной схемы (новое положение и токи ЭПС, новые токи отсосов, новые наведенные напряжения в рельсах от контактной подвески)
 *      2. Повторили пункты 3 и 4 из списка выше
 *
 *
 *  Класс Пути (Track)
 *      Класс содержит данные по мгновенной схеме конкретного пути
 *
 *  Класс Сетка (Mesh)
 *      Класс описания расчетной сетки методом конечных разностей
 *      Пути одного направления имеют общую сетку
 *      Понять одно ли направление или нет можно по общей системе пикетажа - если у путей общая система питетов то это одно напраление
 *
 *  Класс Междупутных соединителей (MPS)
 *      Данный класс содержит описание междупутного соединителя
 *
 *  Класс хранит взаимные междупутных сопротивлений распределенные по сетки с принадлежностью к сектам (RelativeResist),
 *      Процесс использования:
 *      val relativeResist = RelativeResist()
 *      relativeResist.set( MeshRelativeResist( mutableMapOf( MRRKey(track4, track5) to arrayOf(PV(0.0, rpRes)))))
 *
 *  Класс взаимного сопротивления между путями принадлежащим одной сетке (MRR)
 *   Пример описания междупутных сопротивлений между тремя путями на одной расчетной сетке
 *      val r = MeshRelativeResist(mutableMapOf( MRRKey(track0, track1) to arrayOf(PV(138.0, rpRes)),
 *                                               MRRKey(track0, track2) to arrayOf(PV(138.0, rpRes)),
 *                                               MRRKey(track1, track2) to arrayOf(PV(138.0, rpRes))  ))
 *      relativeResist.set( r )
 *
 *  Класс расчета мгновенной схемы (Compute)
 *  Принимает массив путей, междупутных соединителей. сеток и массив междупутных сопротивлений
 *  val calc = Compute (
 *         arrayOf(track0,track1,track2,track3,track4,track5),     /*массив путей*/
 *         mps,                                                    /*массив междупутных соединителей*/
 *         arrayOf(mesh0,mesh1, mesh2),                            /*массив сеток*/
 *         relativeResist,                                         /*массив междупутных сопротивления*/
 *     )
 *      calc.calcOts()
 *
 *   Класс задания какой-то величины и координаты (PV)
 *   Широко используется для задания например сопротивления рельсов в зависимости от координаты вдоль пути
 *
 *   Далее в функции main смотри что для чего было нужно
 */
fun main() {

    /*
    Пример расчета нескольких мгновенных схем
    для участка с 3главными путями, отходящим тупиком и отходящим двухпутным ответвлением
    Имитация движения ЭПС с помощью вспомогательного класса MoveImitator
    последнее для тестирования обработчика результатов расчета токов и напряжений в путях по нескольким мгновенным схемам
    Обработчик результатов в классе Data
    */

    /**
     * Создать расчетные сетки.
     * Зададим начальные и конечные координаты и шаг сетки
     */
    val mesh0 = Mesh(138.0,180.0, 0.1)  // сетка гл. пути 1-3
    val mesh1 = Mesh(0.0,7.0, 0.1)      // сетка отходящий тупик
    val mesh2 = Mesh(0.0,14.0, 0.1)     // сетка отходящие два пути

    /**
     * Создадим массивы наведенных напряжений вдоль пути в зависимости от координаты
     * Если напряжение меняется то элементов PV может быть любое количество
     */
    val u0 = arrayOf( PV(0.0, 0.0.R) ) // для гл. путей - сетка mesh0
    val u1 = arrayOf( PV(0.0, 0.0.R )) // для отходящего тупика - сетка mesh1
    val u2 = arrayOf( PV(0.0, 0.0.R) ) // для отходящей двухпутной ветки - сетка mesh2

    /**
     * Зададим погонное сопротивление рельсов для 1,2,3 путей. Главные пути
     */
    val r13 = arrayOf( PV(189.0, 0.12615.R+0.5871.I) )
    /**
     * Зададим переходное сопротивление рельс-земля для 1,2,3 путей. Главные пути
     */
    val rp13 = arrayOf( PV(179.0, 20.R) )
    /**
     * Зададим погонное сопротивление рельсов для 4 пути. Отходящий тупик.
     */
    val r4 = arrayOf( PV(8.0, 0.12615.R+0.5871.I) )
    /**
     * Зададим переходное сопротивление рельс-земля, для 4 пути. Отходящий тупик.
     */
    val rp4 = arrayOf( PV(8.0, 1.1.R) )
    /**
     * Зададим погонное сопротивление рельсов, для 5,6 путей. Вторая отходящая ветка
     */
    val r56 = arrayOf( PV(15.0, 0.12615.R+0.5871.I) )
    /**
     * Зададим переходное сопротивление рельс-земля для 5,6 путей. Вторая отходящая ветка
     */
    val rp56 = arrayOf( PV(15.0, 10.R) )

    /**
     * Зададим расположение и токи фидеров отсоса для данной мгновенной схемы
     */
    val fot0 = arrayOf( PV(140.5, 2300.R), PV(160.2, 2400.R), PV(176.7, 3000.R) ) // отсосы по первому главному пути
    val fot4 = arrayOf( PV(10.2, 1400.R) ) // отсос для пути

    /**
     * Зададим расположение и токи ЭПС
     */
    val eps0 = arrayOf( PV(149.0, 800.R), PV(171.2, 3400.R) )  // гл. путь1
    val eps1 = arrayOf( PV(156.7, 1900.R) )                         // гл. путь2
    val eps2 = arrayOf( PV(145.3, 1600.R) )                         // гл. путь3
    val eps5 = arrayOf( PV(12.1, 1400.R) )                          // отход двухпутная ветка путь2

    /**
     * Пустой массив чего-то, для задания отсутствующих элементов в данной мгновенной схеме
     * Необходим технически для отсутствующих массивов в параметрах класса Track
     */
    val emp = arrayOf<PV>()

    /**
     * Создадим пути
     *  имя пути задается исключительно для удобства.
     *  Каждому пути указываем его секту, погонное продольное и переходное сопротивление, расположение отсосов(при наличии) ЭПС (при наличии), наведенные напряжения от КС.
     *  Указываем нужно ли рассчитывать сопротивления по границам сетки или они заданы явно, поля iRv0, iRvn
     */
    val track0 = Track("0", mesh0, r13, rp13, fot0, eps0, null, null, u0 )      // гл. путь1
    val track1 = Track("1", mesh0, r13, rp13, emp,  eps1,  null, null, u0)      // гл. путь2
    val track2 = Track("2", mesh0, r13, rp13, emp,  eps2, null, null, u0)       // гл. путь3
    val track3 = Track("3", mesh1, r4,  rp4,  emp,  emp,  1e6.R, 1e6.R, u1 )             // отход тупик
    val track4 = Track("4", mesh2, r56, rp56, fot4, emp,  1e6.R, null, u2 )         // отход двухпутная ветка путь1
    val track5 = Track("5", mesh2, r56, rp56, emp,  eps5, 1e6.R, null, u2 )         // отход двухпутная ветка путь2

    /**
     * Создадим массив междупутных соединителей.
     * Указываем для каждого соединителя:
     * пути, которые он соединяет
     * координаты, в которых соединяет пути
     * сопротивление соединителя
     */
    val mps = arrayOf(
        Mps(track0, track1, 140.5, 140.5, 0.9e-3.R), /*МПС по главным путям 1-3*/
        Mps(track1, track2, 140.5, 140.5, 0.9e-3.R),
        Mps(track0, track1, 151.5, 151.5, 1.5e-3.R ),
        Mps(track0, track2, 155.5, 155.5, 1.6e-3.R ),
        Mps(track0, track1, 160.2, 160.2, 1.4e-3.R ),
        Mps(track1, track2, 160.2, 160.2, 1.1e-3.R ),
        Mps(track1, track2, 167.2, 167.2, 1.4e-3.R ),
        Mps(track0, track1, 176.7, 176.7, 0.7e-3.R ),
        Mps(track1, track2, 177.1, 177.1, 1.8e-3.R ),

        Mps(track4, track5, 10.2, 10.2, 1.0e-3.R ), /*МПС по отход2*/
        Mps(track0, track3, 152.5, 0.0, 1.0e-5.R ), /*соединение путь гл1 (путь 0 в классе) и однопутн отход тупик (путь 3 в классе)*/
        Mps(track1, track4, 170.5, 0.0, 1.0e-5.R ), /*соединение путь гл2 (путь 1 в классе) и  отход2 путь1 (путь 4 в классе) */
        Mps(track2, track5, 170.5, 0.0, 1.0e-5.R ), /*соединение путь гл3 (путь 2 в классе) и  отход2 путь2 (путь 5 в классе) */
    )

    /**
     *    Далее задается междупутное взаимное сопротивление. Оно задается между путями, у которых одна общая сетка.
     *    Т.е. при взаимном сопротивлении фактически должна быть общая система координат вдоль пути.
     *    Поэтому ниже оно задано между всеми тремя главными путями и между двумя путями отходящей двухпутной ветки.
     *    Тупик имеет свою отдельную сетку и не связан с другими путями индуктивно.
     *    Также индуктивно считаются не связанными главные пути и отходящие пути второй ветки
     *    Взаимное сопротивление реализовано через классы RelativeResist и MeshRelativeResist
     */
    val rpRes=0.04.R+0.3.I      //оставил тоже значение междупутного соединения
    val relativeResist = RelativeResist()   //объект хранит междупутные сопротивления
    val meshRelativeResist = MeshRelativeResist( mutableMapOf(   MRRKey(track0, track1) to arrayOf(PV(138.0, rpRes)),   // между гл1 и гл2
        MRRKey(track0, track2) to arrayOf(PV(138.0, rpRes)),                                                            // между гл1 и гл3
        MRRKey(track1, track2) to arrayOf(PV(138.0, rpRes))                                                             // между гл2 и гл3
    ))
    relativeResist.set(meshRelativeResist)
    relativeResist.set(MeshRelativeResist( mutableMapOf( MRRKey(track4, track5) to arrayOf(PV(0.0, rpRes)))))           // между отход2_пут1 и отход2_пут2

    /**
     * Создадим экземпляр расчетного класса для расчета мгновенной схемы
     * Заданные:
     *      положение и токи электроподвижных единиц,
     *      токи фидеров отсоса
     *      Наведенные в рельсах напряжения от контактной подвески
     * -  задают одну мгновенную схему которую можно рассчитать запустив calcOts()
     */
    val calc = Compute (
        arrayOf(track0,track1,track2,track3,track4,track5),     /*массив путей*/
        mps,                                                    /*массив междупутных соедитнителей*/
        arrayOf(mesh0,mesh1, mesh2),                            /*массив сеток*/
        relativeResist,                                         /*массив межупутных сопротивдления*/
    )

    /**
     * Пример расчетна нескольких мгновенных схем и доступ к статистике
     * tics - Всего будет рассчитанно 15 мгновенных схем
     * dEps - В каждой новой мгновенной схеме поезд смещается на 0,1 км
     * Пересчет токов фидеров производится не будет
     * Токи поездов изменяться не будут тоже
     */
    val tics = 15
    val dEps = 0.1

    /**
     * Используем простенький имитатор движения поездов по путям в сторону увеличения их координат
     */
    val epsArray = arrayOf(eps0, eps1, eps2, emp, emp, eps5)
    val imit = MoveImitator (calc, epsArray, dEps )
    for (i in 1..tics) {
        imit.tic()
    }
    /**
     * Класс сбора статистики
     * Собирает по всем рассчитанным мгновенным схемам:
     *  1. максимальные и минимальные напряжения в каждом узле сетки
     *  2. Среднее и стандартное отклонение напряжения в каждом ущле сетки
     *  3. Средние положительные значения напряжения в каждом узле сетки
     *  4. RMS тока по каждому узлу сетки
     */
    val dt = Data(  arrayOf(track0,track1,track2,track3,track4,track5) )
    dt.print(0)
    /**
     * Сохраним в файл результаты обработки всех мгновенных схем по главному первому пути (track0 в данном случае)
     * Результат в виде двумерного массива. Столбец - это параметр (средне, макисмум и т.д.), сторока - это элемент сетки
     */
    dt.write2csv("./track0.csv", 0)

}