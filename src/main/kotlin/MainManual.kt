import ots.calc.*
import ots.calc.Mesh
import ots.calc.Track
import ots.complex.*
import ots.statistic.Data
import ots.statistic.MoveImitator

/**
 * Руководство пользователя системы анализа обратной тяговой сети
 * Как это работает:
 * 1. Все начинается с класса Compute который производит расчет анализа
 *      val calc = Compute (
 *           arrayOf(track0,track1,track2,track3,track4,track5),     /*массив путей*/
 *           mps,                                                    /*массив междупутных соедитнителей*/
 *           arrayOf(mesh0,mesh1, mesh2),                            /*массив сеток*/
 *           relativeResist,                                         /*массив межупутных сопротивдления*/
 *       )
 *      calc.calcOts()
 *  2. Расчет одно текущей мгновенной схемы производится путем:
 *      calc.calcOts()
 *  3. Получить данные токов и напряжений пок аждому пути можно получить из класса путей для только что расчитанной мгновенной схемы
 *      track.I - массив токов в узлах сетки
 *      track.U - массив напряжений в узлах сетки
 *  4. Класс пути может сохранить расчитанные токи и напряжения текущей мгновенной схемы в массивы исторических значений
 *      Для этого используется функция copy2Hist, которая в массивы histU/histI сохраняет расчтанные значения для последней мгноенной схемы
 *      Кажды элемент массива histU/histI - это массивы напряжений/токов для рассчитанных мгновенных схем
 *  Таким образом работа с данным модулей выглядит так
 *      1. Описали мгновенную схему (что это значит - чуть позже)
 *      2. Вызвали calc.calcOts() - рассчитали токи и напряжения в ОТС
 *      3. Для каждого пути вызывали метрод copy2Hist
 *      4. Обновили описание мгновенной схемы (новое положение ЭПС, новые токи отсосов, новые наведенные напряжения в рельсах от контактной подвески)
 *      5  Перезапустили calc.calcOts()
 *
 *  Класс Пути (Track)
 *      Класс содержит данные по мгновенной схеме конкретного пути
 *
 *  Класс Сетка (Mesh)
 *      Класс описания расчкетной сетки метода конечных разностей
 *      Пути одного направления имеют общую сетку
 *      Понять одно ли направление или нет можно по общей системе питекажа - если у путей общая система питетов то это одно напраление
 *
 *  Класс Междупутных соединителей (MPS)
 *      Данный класс содержит описание междупутного соединителя
 *
 *  Класс хранит взаимные междупутных сопротилений распрежеденные по сетки с принадлежностью к сектам (RelativeResist),
 *      Процесс использования:
 *      val relativeResist = RelativeResist()
 *      relativeResist.set( MeshRelativeResist( mutableMapOf( MRRKey(track4, track5) to arrayOf(PV(0.0, rpRes)))))
 *
 *  Класс взаимного сопротивления между путями принадлежащим одной сетке (MRR)
 *   Пример описания междупутных сопротивлений между тремы путями на одной расчетной сетке
 *      val r = MeshRelativeResist(mutableMapOf( MRRKey(track0, track1) to arrayOf(PV(138.0, rpRes)),
 *                                               MRRKey(track0, track2) to arrayOf(PV(138.0, rpRes)),
 *                                               MRRKey(track1, track2) to arrayOf(PV(138.0, rpRes))  ))
 *      relativeResist.set( r )
 *
 *  Класс расчета мгновенной схемы (Compute)
 *  Принимает массив путей, междупутных соединителей. сеток и массив междупутных сопротивлений
 *  val calc = Compute (
 *         arrayOf(track0,track1,track2,track3,track4,track5),     /*массив путей*/
 *         mps,                                                    /*массив междупутных соедитнителей*/
 *         arrayOf(mesh0,mesh1, mesh2),                            /*массив сеток*/
 *         relativeResist,                                         /*массив межупутных сопротивдления*/
 *     )
 *      calc.calcOts()
 *
 *   Класс задания какой-то велинчны и координаты (PV)
 *   Широко используется для задания например сопротивления рельсво в зависимости от координты вдоль пути
 *
 *   Далее в функции main смотри что для чего было нужно
 */
fun main() {
    /**
     * Создадим расчетные сетки
     * Зададим начальные и конечные координаты и шаг сетки
     */
    val mesh0 = Mesh(138.0,180.0, 0.1)
    val mesh1 = Mesh(0.0,7.0, 0.1)
    val mesh2 = Mesh(0.0,14.0, 0.1)

    /**
     * Создадим массивы наведенных напряжений в доль пути в зависисмости от координаты
     * Если напряжение меняептся то элементов PV может быть любое количесво
     */
    val u0 = arrayOf( PV(0.0, 0.0.R) )
    val u1 = arrayOf( PV(0.0, 0.0.R ))
    val u2 = arrayOf( PV(0.0, 0.0.R) )

    /**
     * Зададим погонное сопротивление рельсов,  для 1,2,3 путей
     */
    val r13 = arrayOf( PV(189.0, 0.12615.R+0.5871.I) )
    /**
     * Зададим переходное сопротивление рельс-земля, для 1,2,3 путей
     */
    val rp13 = arrayOf( PV(179.0, 20.R) )
    /**
     * Зададим погонное сопротивление рельсов,  для 4 пути
     */
    val r4 = arrayOf( PV(8.0, 0.12615.R+0.5871.I) )
    /**
     * Зададим переходное сопротивление рельс-земля, для 4 пути
     */
    val rp4 = arrayOf( PV(8.0, 1.1.R) )
    /**
     * Зададим погонное сопротивление рельсов, для 5,6 путей
     */
    val r56 = arrayOf( PV(15.0, 0.12615.R+0.5871.I) )
    /**
     * Зададим переходное сопротивление рельс-земля, для 5,6 путей
     */
    val rp56 = arrayOf( PV(15.0, 10.R) )

    /**
     * Задаиим расположение и токи фидеров остоса тягового тока для данной мгновенной схемы
     */
    val fot0 = arrayOf( PV(140.5, 2300.R), PV(160.2, 2400.R), PV(176.7, 3000.R) )
    val fot4 = arrayOf( PV(10.2, 1400.R) )

    /**
     * Задаиим расположение и токи фидеров электроподвижных единиц
     */
    val eps0 = arrayOf( PV(149.0, 800.R), PV(171.2, 3400.R) )
    val eps1 = arrayOf( PV(156.7, 1900.R) )
    val eps2 = arrayOf( PV(145.3, 1600.R) )
    val eps5 = arrayOf( PV(12.1, 1400.R) )

    /**
     * Пустой массив чего-то, для задания отсутвующих элементов в даннйо мгновенной сзееме
     */
    val emp = arrayOf<PV>()

    /**
     * Создадим пути
     *  имя пути задается исключительно для удобства.
     *  Каждому пути указываем его секту, погонное и сспоротивление изоляции, расположение отсосов(при наличии) электроподвижные единицы (при наличии), наведенные напряжения.
     *  Указываем нужно ли рассчитывать сопротивленеи по границам сетке или они заданы явно, поля iRv0, iRvn
     */
    val track0 = Track("0", mesh0, r13, rp13, fot0, eps0, null, null, u0 )
    val track1 = Track("1", mesh0, r13, rp13, emp,  eps1,  null, null, u0)
    val track2 = Track("2", mesh0, r13, rp13, emp,  eps2, null, null, u0)
    val track3 = Track("3", mesh1, r4,  rp4,  emp,  emp,  1e6.R, 1e6.R, u1 )
    val track4 = Track("4", mesh2, r56, rp56, fot4, emp,  1e6.R, null, u2 )
    val track5 = Track("5", mesh2, r56, rp56, emp,  eps5, 1e6.R, null, u2 )

    /**
     * Создадим массив междупутных содинителей
     * Указываем для каждого соединителя пути которые соединяет, ординаты в которых соединяет пути и сопротивление соединителя
     */
    val mps = arrayOf(
        Mps(track0, track1, 140.5, 140.5, 0.9e-3.R), /*МПС по главным путям 1-3*/
        Mps(track1, track2, 140.5, 140.5, 0.9e-3.R),
        Mps(track0, track1, 151.5, 151.5, 1.5e-3.R ),
        Mps(track0, track2, 155.5, 155.5, 1.6e-3.R ),
        Mps(track0, track1, 160.2, 160.2, 1.4e-3.R ),
        Mps(track1, track2, 160.2, 160.2, 1.1e-3.R ),
        Mps(track1, track2, 167.2, 167.2, 1.4e-3.R ),
        Mps(track0, track1, 176.7, 176.7, 0.7e-3.R ),
        Mps(track1, track2, 177.1, 177.1, 1.8e-3.R ),

        Mps(track4, track5, 10.2, 10.2, 1.0e-3.R ), /*МПС по отход2*/
        Mps(track0, track3, 152.5, 0.0, 1.0e-5.R ), /*соединение путь гл1 (путь 0 в классе) и однопутн отход тупик (путь 3 в классе)*/
        Mps(track1, track4, 170.5, 0.0, 1.0e-5.R ), /*соединение путь гл2 (путь 1 в классе) и  отход2 путь1 (путь 4 в классе) */
        Mps(track2, track5, 170.5, 0.0, 1.0e-5.R ), /*соединение путь гл3 (путь 2 в классе) и  отход2 путь2 (путь 5 в классе) */
    )

    /**
     * Зададим междупутные сопротивления между путями
     * Если пути принадлежат одной сетке то между ними задаем взаимные сопротивления,
     * Если нет - то не задаем
     */
    val rpRes=0.04.R+0.3.I      //оставил тоже значение междупутного соединения
    val relativeResist = RelativeResist()   //объект хранит междупутные сопротивления
    val meshRelativeResist = MeshRelativeResist( mutableMapOf(   MRRKey(track0, track1) to arrayOf(PV(138.0, rpRes)),
        MRRKey(track0, track2) to arrayOf(PV(138.0, rpRes)),
        MRRKey(track1, track2) to arrayOf(PV(138.0, rpRes))
    ))
    relativeResist.set(meshRelativeResist)
    relativeResist.set(MeshRelativeResist( mutableMapOf( MRRKey(track4, track5) to arrayOf(PV(0.0, rpRes)))))
    /**
     * Создадим экземпляр расчетного класса для расчета мгновенной схемы
     * Заданные:
     *      положение и токи электроподвижных единиц,
     *      токи фидеров отсоса
     *      Наведенные в рельсах напряжения от контактной подвески
     * - хзадают одну мгновенную схему которую можно расчитать запустив calcOts()
     */
    val calc = Compute (
        arrayOf(track0,track1,track2,track3,track4,track5),     /*массив путей*/
        mps,                                                    /*массив междупутных соедитнителей*/
        arrayOf(mesh0,mesh1, mesh2),                            /*массив сеток*/
        relativeResist,                                         /*массив межупутных сопротивдления*/
    )

    /**
     * Пример расчетна нескольких мгновенных схем и доступ к статистике
     * tics - Всего будет расчитанно 15 мгновенных схем
     * dEps - В каждой новой мгновенной схеме поезд смещается на 0,1 км
     * Пересчет токов фидеров производится не будет
     * Токи поездов изменяться не будут тоже
     */
    val tics = 15
    val dEps = 0.1

    /**
     * Используем простенький иммитатор перемещабщий поезда по путям в сторону увеличения их начальных координат
     */
    val epsArray = arrayOf(eps0, eps1, eps2, emp, emp, eps5)
    val imit = MoveImitator (calc, epsArray, dEps )
    for (i in 1..tics) {
        imit.tic()
    }
    /**
     * Класс сбора статистики
     * Собирает по всем расчитанным мгновенным схемам:
     *  1. максимальные и минимальные напряжения в каждом узле сетки
     *  2. Среднее и стандартное отклонение напряжения в каждом ущле сетки
     *  3. Средние положительные значения напряжения в каждом узле сетки
     *  4. RMS тока по каждому узлу сетки
     */
    val dt = Data(  arrayOf(track0,track1,track2,track3,track4,track5) )
    dt.print(0)
    /**
     * Созраним в файл данные по первому пути в массива, track0 в данном случае
     */
    dt.write2csv("./track0.csv", 0)

}